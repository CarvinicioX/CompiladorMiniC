package proyecto_compi;
import java.io.*;
import java_cup.runtime.*;
import AST.*; 


parser code
{:
	public void syntax_error(Symbol s){
		report_error("Error de sintaxis. Linea: " + (s.right + 1) +
		" Columna: " + s.left + ". Texto: \"" + s.value + "\"", null);
	}
       


:}

/* Terminals Tokens */



terminal INT, CHAR;
terminal String INTPUNT, CHARPUNT;

terminal String ID;
terminal IF;
terminal ELSE;
terminal WHILE;
terminal FOR;
terminal MAIN; 
terminal RETURN; 
terminal VOID; 
terminal CORCHETEIZQUIERDO; 
terminal CORCHETEDERECHO;
terminal LLAVEIZQUIERDA;
terminal LLAVEDERECHA;
terminal String CONSTCHAR; 
terminal String CONSTSTR;
terminal PARENTESISIZQUIERDO; 
terminal PARENTESISDERECHO;
terminal IGUAL;
terminal PUNTO;
terminal NOT;
terminal PRINTF;
terminal SCANF;
terminal PERCENTAGE;
terminal PERCENTAGEDIGIT;
terminal PERCENTAGESTRING;
terminal PERCENTAGECHART;
terminal String NUM;
terminal BREAK;
terminal MASMAS;
terminal OPERADORSUMA;
terminal OPERADORRESTA;
terminal OPERADORMULTIPLICACION;
terminal OPERADORDIV; 
terminal MENOSMENOS;
terminal MASIGUAL;
terminal MENOSIGUAL;
terminal MULTIIGUAL;
terminal DIVIGUAL;
terminal MODASIGNACION;  
terminal MENORQUE;
terminal MAYORQUE;
terminal MAYORIGUAL;
terminal MENORIGUAL;
terminal NOTIGUAL;
terminal IGUALQUE;
terminal MODARITMETICO;
terminal INTERROGACION;
terminal ANDAND;
terminal OROR;
terminal PUNTOYCOMA;
terminal COMA;
terminal DOSPUNTOS;
terminal PARAMETROSCANF;
terminal AND;
terminal IMPORT;

non terminal arg_list;
non terminal args;
non terminal Assignment_Expression assignment_expression;
non terminal Assignment_ExpressionP assignment_expressionP;
non terminal Assignment_Statement assignment_statement;
non terminal Boolean_Expression boolean_expression;
non terminal condition;
non terminal conditionP;
non terminal Constant constant;
non terminal E1;
non terminal E2;
non terminal E3;
non terminal expr_for;
non terminal Expression_Increment expr_increment;
non terminal Expression expr;
non terminal ExpressionP exprP;
non terminal Factor factor;
non terminal Flag flags;
non terminal for_statement;
non terminal function_call;
non terminal function_call_statement;
//non terminal function_declaration;
non terminal Function_Definition_List function_definition;
non terminal If_Statement if_statement;
non terminal Increment inc ;
non terminal Increment_Special inc_special;
non terminal IncrementI increment;
non terminal IncrementP incrementP;
non terminal arg_listP;
non terminal init_for;
non terminal init_forP;
non terminal Jump_Statement jump_statement;
non terminal Logical_Expression logical_expression;
non terminal Logical_Operator logical_operators;
non terminal Main_Function Main_Function;
non terminal Param_Id param_id;
non terminal Param_List param_list;
non terminal Param_List_P param_listP;
non terminal Param_Type_List param_type_list;
non terminal Params params;
non terminal PrintF printf_statement;
non terminal Relational_Expression relational_expression;
non terminal Relational_Operator relational_operators;
//non terminal S;
non terminal ScanF scanf_statement;
non terminal Statement statement;
non terminal Statement_Inside_If statement_inside_if;
non terminal Statement_Inside_While statement_inside_while;
non terminal Statement_List statement_list;
non terminal Term term;
non terminal TermP termP;
non terminal Type type;
non terminal Variable variable;
non terminal Variable_Declaration variable_declaration ;
non terminal Variable_Init variable_initialization;
non terminal Variable_List variable_list;
non terminal While_Statement while_statement;
//S::= function_declaration S | Main_Function;


Main_Function ::= INT MAIN PARENTESISIZQUIERDO params:p PARENTESISDERECHO LLAVEIZQUIERDA statement_list:sl RETURN expr PUNTOYCOMA LLAVEDERECHA function_definition:fdl {:RESULT = new Main_Function(fdl,p,sl);	:};

variable_declaration ::= type variable_list PUNTOYCOMA
            |type error {: parser.report_error("variable_declarators" ,"ERROR"); :} PUNTOYCOMA
            |type error
            {: parser.report_error("variable_declarators" ,"WRONG"); :}
            statement;

expr ::= term:t exprP:e					{:RESULT = new Expression(t,e);:};
exprP ::= OPERADORSUMA term:t exprP:e                   {:RESULT = new OPlus(t,e);:}
		| OPERADORRESTA term:t exprP:e		{:RESULT = new OMinus(t,e);:}
		|
		;


term ::= factor:f termP:t                               {:RESULT = new Term(f,t);:}
		;

termP ::= OPERADORMULTIPLICACION factor:f termP:p            {:RESULT = new OMult(f,p);:}				
		| OPERADORDIV factor:f termP:p 		{:RESULT = new OMult(f,p);:}
		| 
		;

factor ::=variable:v 				{:RESULT = new Variable_To_Factor(v);:}	
		| PARENTESISIZQUIERDO expr:e PARENTESISDERECHO		{:RESULT = new Factor_Expression(e);:}
		| constant:c 				{:RESULT = c;:}					
		| function_call ;

variable_list ::=   variable_list:list COMA variable_initialization:v               {:list.add_init(v); RESULT = list;:} 
			| variable_initialization:v                                 {:RESULT = new Variable_List(v);:};

variable ::= ID:id                                                                   {:RESULT = new Variable_Identifier(id);:}
			|ID:id CORCHETEIZQUIERDO expr:e CORCHETEDERECHO     {:RESULT = new Variable_ArrayID(id,e);:}
			;

variable_initialization ::= variable_initialization:v IGUAL expr:e              {:RESULT = new Variable_Init_Expression(v,e);:}
			| variable:v                                            {:RESULT = v;:} ;

type ::= INT 							{:RESULT = new Type_Int();:}
	| CHAR 							{:RESULT = new Type_Char();:}
	| CHARPUNT						
	| INTPUNT 						
	;

jump_statement ::= BREAK PUNTOYCOMA 		{:RESULT = new Jump_Break();:}
				| RETURN PUNTOYCOMA 		{:RESULT = new Jump_Return();:}
				| RETURN expr:e PUNTOYCOMA      {:RESULT = new Jump_Return_Expr(e);:};

if_statement ::= IF PARENTESISIZQUIERDO boolean_expression:b PARENTESISDERECHO statement_inside_if:s {:RESULT = new If_Statement(b,s);:}
				| IF error  {: parser.report_error("expression" ,"ERROR"); :} PARENTESISDERECHO statement_inside_if ;

statement_list ::= statement_list:list statement:s          {:list.add(s); RESULT = list;:}
				|                           {:RESULT = new Statement_List();:};

statement::= if_statement:s 							{:RESULT = s;:}
		| jump_statement:s                                              {:RESULT = s;:}
		| assignment_statement:s 					{:RESULT = s;:}
		| function_call_statement 
		| for_statement
		| variable_declaration:s 					{:RESULT = s;:}
		| while_statement:s 						{:RESULT = s;:}
		| printf_statement:s 						{:RESULT = s;:}
		| scanf_statement:s 						{:RESULT = s;:};

statement_inside_if ::= LLAVEIZQUIERDA statement_list:s LLAVEDERECHA     {:RESULT = new Statement_Inside_If_Simple(s);:}
                        |LLAVEIZQUIERDA statement_list:s1 LLAVEDERECHA ELSE LLAVEIZQUIERDA statement_list:s2 LLAVEDERECHA  {:RESULT = new Statement_Inside_If_Complex(s1,s2);:};

printf_statement ::= PRINTF PARENTESISIZQUIERDO CONSTSTR:c COMA expr:e PARENTESISDERECHO PUNTOYCOMA     {:RESULT = new PrintFExpr(e,c);:}
				| PRINTF PARENTESISIZQUIERDO CONSTSTR:c PARENTESISDERECHO PUNTOYCOMA 	{:RESULT = new PrintFString(c);:};

scanf_statement ::=  SCANF PARENTESISIZQUIERDO  flags:f COMA variable:v PARENTESISDERECHO PUNTOYCOMA    {:RESULT = new ScanF(f,v);:};

flags ::= PERCENTAGEDIGIT        {:RESULT = new FlagD();:}
	| PERCENTAGESTRING 	 {:RESULT = new FlagS();:}
	| PERCENTAGECHART 	 {:RESULT = new FlagC();:};

boolean_expression ::= relational_expression:rl logical_expression:le {:RESULT = new Boolean_Expression(rl,le);:};

relational_expression ::=  expr:e1 relational_operators:r expr:e2 {:RESULT = new Relational_Expression(e1,e2,r);:}
							| PARENTESISIZQUIERDO relational_expression:rl PARENTESISDERECHO {:RESULT = rl;:}
							| error {: parser.report_error("relational_expression","ERROR"); :} 
                                MENORQUE expr
                              | error {: parser.report_error("relational_expression","ERROR"); :} 
                                MAYORQUE expr
                              | error  {: parser.report_error("relational_expression","ERROR"); :} 
                                MENORIGUAL expr
                              | error {: parser.report_error("relational_expression" ,"ERROR"); :} 
                                MAYORIGUAL expr ;

relational_operators ::=  MENORIGUAL      {:RESULT = new Operator_LTEQ();:}
					| MENORQUE 			{:RESULT = new Operator_LT();:}
					| MAYORQUE 			{:RESULT = new Operator_GT();:}
					| MAYORIGUAL 			{:RESULT = new Operator_GTEQ();:}
					| IGUALQUE 			{:RESULT = new Operator_EQEQ();:}
					| NOTIGUAL			{:RESULT = new Operator_NOTEQ();:};

logical_expression ::= logical_operators:lo boolean_expression:bo {:RESULT = new Logical_Expression(lo,bo);:}
					|	{:RESULT = new Logical_Expression();:};

logical_operators ::= ANDAND 		{:RESULT = new Logical_AND();:}
					| OROR		{:RESULT = new Logical_OR();:}
					;

function_definition ::= type:t ID:id PARENTESISIZQUIERDO params:p PARENTESISDERECHO LLAVEIZQUIERDA statement_list:sl LLAVEDERECHA function_definition:list  {:list.add(new Function_Definition(t,p,sl)); RESULT = list;:}
					|  {:RESULT = new Function_Definition_List();:}
					;

assignment_statement ::= assignment_expression:a PUNTOYCOMA		{:RESULT = new Assignment_Statement(a);:};

assignment_expression ::= variable_initialization:v assignment_expressionP:a                            {:RESULT = new Assignment_Expression_Var_Init(v,a);:}
						| expr_increment:e assignment_expressionP:a		{:RESULT = new Assignment_Expression_Increment(e,a);:}
						;
assignment_expressionP ::= variable_initialization:v assignment_expressionP:a                           {:RESULT = new Assignment_ExpressionP_Var(v,a);:}
                            |{:RESULT = new Assignment_ExpressionP_Empty();:};


params ::= param_list:list                                              {:RESULT = new Params(list);:}
		| {:RESULT = new Params();:};		

param_list ::= param_type_list:p param_listP:list 			{:list.add(p); RESULT = list;:}
			| error 
      {: parser.report_error("formal_parameter_list","ERROR"); :} 
    COMA param_type_list param_listP;

param_listP ::= COMA param_type_list:p param_listP:list	{:list.add(p); RESULT = list;:}
			|			{:RESULT = new Param_List_P();:}
			;

param_type_list ::= type:t param_id:id 	{:RESULT = new Param_Type_List(t,id);:};

param_id ::= ID:id 							{:RESULT = new Param_Id_Identifier(id);:}
		| ID:id CORCHETEIZQUIERDO CORCHETEDERECHO 		{:RESULT = new Param_Id_Array(id);:};

while_statement ::= WHILE PARENTESISIZQUIERDO boolean_expression:b PARENTESISDERECHO statement_inside_while:s {:RESULT = new While_Statement(b,s);:}
			| WHILE error 
      {: parser.report_error("expression" , "WRONG"); :}
    PARENTESISDERECHO statement;

statement_inside_while ::= LLAVEIZQUIERDA statement_list:sl LLAVEDERECHA    {:RESULT = new Statement_Inside_While(sl);:};

for_statement ::= FOR PARENTESISIZQUIERDO expr_for PARENTESISDERECHO LLAVEIZQUIERDA statement_list LLAVEDERECHA;

expr_for ::= E1 PUNTOYCOMA E2 PUNTOYCOMA E3;

E1 ::= init_for| ;
E2 ::= condition| ;
E3 ::= increment| ;

constant ::= CONSTCHAR:c {:RESULT = new Literal_Char(c);:}
		| CONSTSTR:s 	{:RESULT = new Literal_String(s);:}
		| NUM:i		{:RESULT = new Literal_Integer(i);:}
		;

init_for ::= INT assignment_expression init_forP
			| assignment_expression
			;

init_forP ::= COMA INT assignment_expression init_forP
			| COMA assignment_expression
			|
			;

condition ::= ID relational_operators expr conditionP;
conditionP ::= COMA ID relational_operators expr conditionP
			|
			;

function_call ::= ID PARENTESISIZQUIERDO args PARENTESISDERECHO;
function_call_statement ::= function_call PUNTOYCOMA;

increment ::= expr_increment:e incrementP:i {:RESULT = new IncrementI(e,i);:};

incrementP ::= COMA expr_increment:e incrementP:i 		{:RESULT = new IncrementP_P(e,i);:}
			|					{:RESULT = new IncrementP_Empty();:}
			;

expr_increment ::= variable:v inc:i 	{:RESULT = new Expression_Increment_VarInc(v,i);:} 
				| inc_special:i variable:v {:RESULT = new Expression_Increment_Special_Variable(v,i);	:};

inc ::= MENOSIGUAL expr:e  	{:RESULT = new Increment_MinEq(e);:}
	| MENOSMENOS 		{:RESULT = new Increment_MinMin();:}
	| MASIGUAL expr:e 	{:RESULT = new Increment_PlusEq(e);:} 
	| MASMAS 			{:RESULT = new Increment_PlusPlus();:}
	| DIVIGUAL expr:e 		 {:RESULT = new Increment_DivEq(e);:}
	| MULTIIGUAL expr:e 	 {:RESULT = new Increment_MultEq(e);:};

inc_special ::= MASMAS 	{:RESULT = new Increment_Special_PP();:}
			| MENOSMENOS 	{:RESULT = new Increment_Special_MM();:};

args::= arg_list 
		| ;

arg_list ::= expr arg_listP 
		;

arg_listP ::= COMA expr arg_listP
			|
			;
